{% extends "_base.html" %}
{% block title %}Works - Binary Tree Visualizer{% endblock %}

{% block content %}

<div class="queue-wrapper">
    <h2>Binary Tree</h2>
<p class="page-description">A hierarchical data structure that consists of nodes connected by edges.</p>

<form method="POST" class="queue-form">
    <div class = "input-container" style="gap: 12px;">
        <input type="text" name="value" placeholder="Enter value">

        {% if tree_root %}
          <input type="text" name="target" placeholder="Enter target (for deletion and insertion)">
        {% endif %}
    </div>
    <div class="button-container">
        <button type="submit" name="insert-root" class="btn-glow">Insert Root</button>

        {% if tree_root %}
          <button type="submit" name="insert-left" class="btn-glow">Insert Left</button>
          <button type="submit" name="insert-right" class="btn-glow">Insert Right</button>
          <button type="submit" name="delete-node" class="btn-glow">Delete Node</button>
          <button type="submit" name="reset-tree" class="btn-glow">Reset Tree</button>
        {% endif %}
    </div>
</form>

<div class="queue-display">
    {% if tree_nodes|length == 0 %}
        <div class="empty-msg">Tree is empty</div>
    {% else %}
        <!-- stage and svg required by the JS -->
        <div id="treeStage" style="position:relative; min-width:700px; height:400px;">
            <svg id="treeSvg" style="position:absolute; left:0; top:0; width:100%; height:100%; overflow:visible;"></svg>

            {% for node in tree_nodes %}
            <div
                class="tree-node-abs queue-box"
                data-index="{{ node.index }}"
                data-parent="{{ node.parent }}"
                data-level="{{ node.level }}"
            >
                {{ node.value }}
            </div>
            {% endfor %}
        </div>
    {% endif %}
</div>

<style>
/* ensure nodes can be absolutely positioned by the layout script */
.tree-node-abs {
  position: absolute;
  transform: translate(-50%, -50%);
  /* queue-box styles already provide appearance; adapt as needed */
}
.branch-line {
  fill: none;
  stroke: rgba(0,230,255,0.8);
  stroke-width: 3;
  stroke-linecap: round;
}
</style>

<script>
function layoutTreeAndBranches() {
  // grab DOM elements for the stage container and the svg where links will be drawn
  const stage = document.getElementById("treeStage");
  const svg = document.getElementById("treeSvg");
  if (!stage || !svg) return;

  // collect all visual node elements; bail out if none
  const nodes = Array.from(stage.querySelectorAll(".tree-node-abs"));
  if (!nodes.length) return;

  // create map from numeric heap-style index -> element for fast lookups
  const byIndex = {};
  nodes.forEach(n => byIndex[+n.dataset.index] = n);

  // build(): recursively rebuilds a simple JS-tree structure from the flat DOM nodes
  // each node object contains: index, level, el (DOM element), left, right
  function build(index=0, level=0) {
    const el = byIndex[index];
    if (!el) return null;
    return {
      index,
      level,
      el,
      left: build(index*2 + 1, level+1),
      right: build(index*2 + 2, level+1)
    };
  }

  const root = build(0,0);
  if (!root) return;

  // layout constants: vertical spacing between levels and top padding
  const levelGap = 120;
  const topPad = 40;

  // measure chips to compute horizontal spacing constraints
  const allBoxes = nodes.map(n => n.getBoundingClientRect());
  const maxChipW = Math.max(...allBoxes.map(b => b.width));

  // base horizontal gap logic: ensures nodes don't collide
  const baseGap = 32;
  const nodeGapMin = maxChipW + baseGap;

  // nextX acts as a cursor for leaf placement (left-to-right)
  let nextX = 0;

  // layout(node): recursive layout that assigns node.centerX based on children
  function layout(node) {
    if (!node) return { leftX: 0, rightX: 0, centerX: 0 };

    const L = layout(node.left);
    const R = layout(node.right);

    if (!node.left && !node.right) {
      const w = node.el.getBoundingClientRect().width;
      const step = Math.max(nodeGapMin, w + baseGap);
      const cx = nextX;
      nextX += step;
      node.centerX = cx;
      return { leftX: cx, rightX: cx, centerX: cx };
    }

    if (node.left && !node.right) {
      node.centerX = L.centerX;
      return { leftX: L.leftX, rightX: L.rightX, centerX: node.centerX };
    }
    if (!node.left && node.right) {
      node.centerX = R.centerX;
      return { leftX: R.leftX, rightX: R.rightX, centerX: node.centerX };
    }

    node.centerX = (L.centerX + R.centerX) / 2;
    return { leftX: L.leftX, rightX: R.rightX, centerX: node.centerX };
  }

  // run layout to populate centerX values and compute nextX (overall width)
  layout(root);

  // compute stage size based on layout results and max level depth
  const treeWidth = Math.max(0, nextX - nodeGapMin);
  const stageWidth = Math.max(700, treeWidth + maxChipW * 2);
  const maxLevel = Math.max(...nodes.map(n => +n.dataset.level));
  const height = topPad + (maxLevel + 1) * levelGap;

  stage.style.width = stageWidth + "px";
  stage.style.height = height + "px";

  // center the tree horizontally inside the stage
  const offsetX = (stageWidth - treeWidth) / 2;

  // applyPositions(): set CSS left/top for each chip based on computed centerX & level
  function applyPositions(node) {
    if (!node) return;
    node.el.style.left = (node.centerX + offsetX) + "px";
    node.el.style.top = (topPad + node.level * levelGap) + "px";
    applyPositions(node.left);
    applyPositions(node.right);
  }
  applyPositions(root);

  // prepare SVG: size + clear previous branch paths
  svg.setAttribute("width", stageWidth);
  svg.setAttribute("height", height);
  svg.setAttribute("viewBox", `0 0 ${stageWidth} ${height}`);
  svg.innerHTML = "";

  // build a map index -> layout node object for drawing
  const layoutMap = {};
  (function collect(n){
    if (!n) return;
    layoutMap[n.index] = n;
    collect(n.left);
    collect(n.right);
  })(root);

  // Draw branches using layout coordinates (stage-relative), not viewport rects
  nodes.forEach(childEl => {
    const parentIdx = childEl.dataset.parent;
    if (parentIdx == null || parentIdx === "") return;
    const parentNode = layoutMap[+parentIdx];
    const childNode  = layoutMap[+childEl.dataset.index];
    if (!parentNode || !childNode) return;

    // center positions relative to stage
    const pCx = parentNode.centerX + offsetX;
    const pCy = topPad + parentNode.level * levelGap;
    const cCx = childNode.centerX + offsetX;
    const cCy = topPad + childNode.level * levelGap;

    const pW = parentNode.el.offsetWidth;
    const pH = parentNode.el.offsetHeight;
    const cW = childNode.el.offsetWidth;
    const cH = childNode.el.offsetHeight;

    const childIndex = +childEl.dataset.index;
    const parentIndex = +parentIdx;
    const isLeft = childIndex === parentIndex * 2 + 1;
    const side = isLeft ? -1 : 1;

    const startEdgeOffset = pW * 0.35;
    const startX = pCx + side * startEdgeOffset;
    const startY = pCy + pH/2 - 2;

    const endX = cCx;
    const endY = cCy - cH/2 + 2;

    const maxR = Math.max(pH/2, cH/2);
    // positive reach so curves are visible
    const reach = Math.max(0, maxR * 1.8);
    const pull  = Math.min(100, maxR * 1.1);

    const c1X = startX + side * reach;
    const c1Y = startY + pull;
    const c2X = endX   - side * reach;
    const c2Y = endY   - pull;

    const path = document.createElementNS("http://www.w3.org/2000/svg","path");
    path.setAttribute(
      "d",
      `M ${startX} ${startY} C ${c1X} ${c1Y}, ${c2X} ${c2Y}, ${endX} ${endY}`
    );
    path.setAttribute("class","branch-line");
    svg.appendChild(path);
  });

  // If a node was marked as "found-node" (e.g., from a search), scroll so it is vertically centered.
  const foundEl = stage.querySelector(".found-node");
  if (foundEl){
    const r = foundEl.getBoundingClientRect();
    const targetY =
      window.scrollY + r.top - (window.innerHeight / 2 - r.height / 2);
    window.scrollTo({ top: Math.max(0, targetY), behavior: "smooth" });
  }
}

// run layout after load; the double requestAnimationFrame gives the browser a chance to finish layout/paint
window.addEventListener("load", () =>
  requestAnimationFrame(() => requestAnimationFrame(layoutTreeAndBranches))
);
// re-run layout on window resize but defer with rAF to avoid excessive synchronous layout thrashing
window.addEventListener("resize", () =>
  requestAnimationFrame(layoutTreeAndBranches)
);
</script>

{% endblock %}